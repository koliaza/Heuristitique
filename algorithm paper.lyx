#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref section
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
An heuristic for graph isomorphisms
\end_layout

\begin_layout Author
\begin_inset ERT
status open

\begin_layout Plain Layout

Nguy
\backslash
~{
\backslash
^e}n Lê Thành D
\backslash
~ung 
\backslash
and  Blanchard Nicolas Koliaza
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Foreword 
\end_layout

\begin_layout Standard
The problem considered is the graph isomorphism (GI) problem : given two
 graphs 
\begin_inset Formula $G$
\end_inset

 and 
\begin_inset Formula $G'$
\end_inset

, can one compute an isomorphism between them.
 The original goal was to implement the Weisfeiler-Lehman heuristic in the
 C programming language, but we chose to implement our own heuristic to
 test its performance.
 The precise goal was to find an heuristic which would behave polynomially
 on the a bigger subset of problems, even if the polynomial degree increases.
 
\end_layout

\begin_layout Section
Algorithmical Considerations
\end_layout

\begin_layout Standard
We adopt the notations of graphs with n vertices and m edges.
 
\begin_inset Formula $G(n,p)$
\end_inset

 denotes the graph generated through the Erdös-Rényi model with n vertices
 and probability p for each edge.
 
\end_layout

\begin_layout Standard
There is a strong link between GI and algebra : finding an isomorphism is
 the same as finding a basis in which the adjacency matrix of G becomes
 that of G'.
 Testing all solutions is equivalent to testing all permutations and a naïve
 algorithm would take 
\begin_inset Formula $n!$
\end_inset

 operations.
 The GI problem lies between the complexity classes P and NP and Schöning
 
\begin_inset CommandInset citation
LatexCommand cite
key "Schoening1988"

\end_inset

 proved that it is not NP-complete unless 
\begin_inset Formula $P=NP$
\end_inset

.
 However, no polynomial solution has been found and the best deterministic
 algorithm so far is due to Eugene Luks and runs in 
\begin_inset Formula $2^{O(\sqrt{n\, logn})}$
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Babai1983"

\end_inset

.
 However some efficient heuristics are available, including 
\emph on
nauty
\emph default
 and 
\emph on
conauto
\emph default
, which runs in 
\begin_inset Formula $O(n^{5})$
\end_inset

 with very high probability for any graph in 
\begin_inset Formula $G(n,p)$
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Lopez-Presa2009"

\end_inset

.
 In our algorithm and test we often consider multi-graphs, as the hard cases
 are much easier to generate for multi-graphs and the difference has no
 impact on our heuristic.
 Finally, we tried to make an heuristic which would behave well when launched
 on p different graphs to check if any two are isomorphic.
\end_layout

\begin_layout Section
The Heuristics
\end_layout

\begin_layout Subsection
The Weisfeiler-Lehman heuristic
\end_layout

\begin_layout Standard
The original Weisfeiler-Lehman (WL) heuristic works by coloring the edges
 of a graph according to the following rules :
\end_layout

\begin_layout Itemize
We begin with a coloring that assigns to every vertex the same color (this
 is the 1-dimensional version).
\end_layout

\begin_layout Itemize
At each pass, the color of each vertex is determined by the number of neighbours
 of color c for each c.
\end_layout

\begin_layout Itemize
After at most n passes, the colors don't change anymore.
\end_layout

\begin_layout Standard
These rules actually only produce a certificate of non-isomorphism.
 To construct an isomorphism using WL one uses backtracking coupled with
 the fact that the image of a vertex has to be of the same color.
 It is easy to see that two isomorphic graphs behave in the same way when
 subject to WL coloring, but the converse does not generally hold.
 Notably, some special classes of graphs make backtracking omnipresent,
 e.g.
 in k-regular graphs, thus leading to time complexity up to 
\begin_inset Formula $O(n^{n})$
\end_inset

.
 The heuristic can be improved by changing the initial coloring of the vertices,
 but we shall only study this case.
\end_layout

\begin_layout Subsection
Another heuristic
\end_layout

\begin_layout Subsubsection
The idea
\end_layout

\begin_layout Standard
Our heuristic is based on the following property : 
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $V_{k}(x)$
\end_inset

 be the number of neighbours at distance exactly k from x, and 
\begin_inset Formula $P_{k}(x)$
\end_inset

 the number of paths of length k starting from x, then if 
\begin_inset Formula $f$
\end_inset

 is an isomorphism between 
\begin_inset Formula $G$
\end_inset

 and 
\begin_inset Formula $G'$
\end_inset

 , 
\begin_inset Formula $V_{k}(x)=V_{k}(f(x))$
\end_inset

 and 
\begin_inset Formula $P_{k}(x)=P_{k}(f(x))$
\end_inset

.
 Thus, by computing the different 
\begin_inset Formula $V_{x}$
\end_inset

 and 
\begin_inset Formula $P_{x}$
\end_inset

 we can prune the search tree and limit the possibilities.
 We name the array of couples 
\begin_inset Formula $P_{k}(x),V_{k}(x)$
\end_inset

 for k between 1 and n PV(x), and compute an array containing PV(x) for
 each x, obtaining the 
\begin_inset Formula $n\times n$
\end_inset

 matrix PV.
 
\end_layout

\begin_layout Subsubsection
The algorithm
\end_layout

\begin_layout Standard
The algorithm we use actually incorporates multiple testing phases to quickly
 eliminate easy cases.
 It can be decomposed in the following steps : 
\end_layout

\begin_layout Enumerate
Lecture and choice of data structure
\end_layout

\begin_layout Enumerate
Primary test phase
\end_layout

\begin_layout Enumerate
Construction of each PV-array 
\end_layout

\begin_layout Enumerate
Sorting of each PV-array
\end_layout

\begin_layout Enumerate
Comparison of the PV-arrays
\end_layout

\begin_layout Enumerate
If possible construction of an isomorphism using backtracking
\end_layout

\begin_layout Subsubsection
First test phase 
\end_layout

\begin_layout Standard
The problem with the naïve algorithm is that the number of possibilities
 groes exponentially in n, however, when one considerons permutations which
 are composed of one transposition, there are at most 
\begin_inset Formula $n^{2}$
\end_inset

possibilities and each take at most 
\begin_inset Formula $m$
\end_inset

 operations.
 The first test phase uses different simple techniques to quickly find a
 certificate of non-isomorphism or an easy isomorphism when doing so is
 possible.
 The tests are run in this order : 
\end_layout

\begin_layout Enumerate
Check for equality between the matrices (runs in 
\begin_inset Formula $O(m)$
\end_inset

)
\end_layout

\begin_layout Enumerate
Check size and number of connected components (in 
\begin_inset Formula $O(m)$
\end_inset

)
\end_layout

\begin_layout Enumerate
Compare the list of degrees (in 
\begin_inset Formula $O(m+n*log(n))$
\end_inset

 ) and record the number of possibilities.
\end_layout

\begin_layout Enumerate
When the number of possibilities is small (
\begin_inset Formula $O(n^{2})$
\end_inset

) use bruteforce (in 
\begin_inset Formula $O(n^{2}*m)$
\end_inset

 ).
\end_layout

\begin_layout Enumerate
Still check for simple transpositions when it is not the case ( also in
 
\begin_inset Formula $O(n^{2}*m)$
\end_inset

 )
\end_layout

\begin_layout Subsubsection
Details and optimization
\end_layout

\begin_layout Standard
The choice of data structures varies between adjacency matrix and list,
 and sometimes both, and allows us to take advantage of faster algorithms
 on sparse graphs using lists, while allowing us to know in O(1) if two
 vertices are linked.
 
\end_layout

\begin_layout Standard
The construction of the V-array is generally the most time-expensive task,
 it is mostly done by multiplication of the adjacency matrix (or by equivalent
 operations on lists).
 Sorting the V-array is easily done with a heapsort.
 The construction of the isomorphism is done by trying to assign to an x
 an y such that
\begin_inset Formula $V(x)=V(y)$
\end_inset

 and backtracking when unsuccessfull.
 
\end_layout

\begin_layout Standard
Some code optimizations have also been added : the construction of V-arrays
 by matrix multiplication can be parallelized easily, and multi-threading
 has been used to do so.
 We also used it for sorting the arrays.
 However we didn't use Strassen's algorithm because for the matrix size
 considered (
\begin_inset Formula $n\le500$
\end_inset

) the gain is very small and mostly compensated by the overhead.
 
\end_layout

\begin_layout Section
Generating Tests
\end_layout

\begin_layout Standard
We have included different basic test generation programs, depending on
 the model : 
\end_layout

\begin_layout Subsection
Random generation
\end_layout

\begin_layout Itemize
The Erdös-Rényi 
\begin_inset Formula $G(n,p)$
\end_inset

 model with probability p for each edge works in general quite fast because
 the probability that two graphs are not isomorphic (and trigger a certificate)
 is very high.
 
\end_layout

\begin_layout Itemize
The similar model with 
\begin_inset Formula $G(n,M)$
\end_inset

 behaves the same way.
\end_layout

\begin_layout Itemize
A model to generate random k-regular multigraphs that generates k random
 permutations of n vertices and links each vertice of the initial array
 to each of its images in the resulting permutations.
 
\end_layout

\begin_layout Standard
All other methods so far for generating k-regular graphs (and not multigraphs)
 are probabilistic except for very small k, and when 
\begin_inset Formula $k\ge log(n)$
\end_inset

 have exponential expected time 
\begin_inset CommandInset citation
LatexCommand cite
key "Wormwald:UniformGeneration"

\end_inset

, so we restricted ourselves to those three models, as our algorithm should
 work as well on multigraphs as on normal graphs.
\end_layout

\begin_layout Subsection
Isomorphic graph generation
\end_layout

\begin_layout Standard
To generate two isomorphic graphs is actually really easy : as two graphs
 are isomorphic if and only if their adjacency matrices are similar, one
 has to compute a random permutation (which corresponds to a change of basis),
 and to apply it to any graph to obtain an isomorphic copy.
 We generate those from all three different models of random graphs already
 implemented.
 
\end_layout

\begin_layout Section
Comparison with Weisfeiler-Lehman
\end_layout

\begin_layout Standard
Let us suppose one finds a coloring using WL that produces a certificate
 of non-isomorphism.
 It does so at the 
\begin_inset Formula $k^{th}$
\end_inset

iteration.
 If 
\begin_inset Formula $k=1$
\end_inset

 then it is simply that the degree list that mattered and our heuristic
 also managed to notice it (it does it quickly thanks to the primary test
 phase, but the PV-array would suffice).
 Now suppose that the two colorings are incompatible, it means that the
 number of vertex of one color isn't the same in both graphs.
 That means that there are two vertices such that they were identically
 colored at 
\begin_inset Formula $k-1$
\end_inset

 but that their neighbourhood were not identically colored.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "bibliography algorithms"
options "plain"

\end_inset


\end_layout

\end_body
\end_document

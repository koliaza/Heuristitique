#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman palatino
\font_sans default
\font_typewriter default
\font_default_family rmdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref section
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
An heuristic for graph isomorphisms
\end_layout

\begin_layout Author
\begin_inset ERT
status open

\begin_layout Plain Layout

Nguy
\backslash
~{
\backslash
^e}n Lê Thành D
\backslash
~ung 
\backslash
and  Blanchard Nicolas Koliaza
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Foreword 
\end_layout

\begin_layout Standard
The problem considered is the graph isomorphism (GI) problem : given two
 graphs 
\begin_inset Formula $G$
\end_inset

 and 
\begin_inset Formula $G'$
\end_inset

, can one compute an isomorphism between them.
 The original goal was to implement the Weisfeiler-Lehman heuristic in the
 C programming language, but we chose to implement our own heuristic (named
 PN for Path-Neighbour) to test its performance.
 The main goal was to find an heuristic which would behave polynomially
 on a bigger subset of problems, even if the polynomial degree increases.
 We adopt the notations of graphs with n vertices and m edges.
 
\begin_inset Formula $G(n,p)$
\end_inset

 denotes the graph generated through the Erdös-Rényi model with n vertices
 and probability p for each edge.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
First Considerations
\end_layout

\begin_layout Standard
There is a strong link between GI and algebra : finding an isomorphism is
 the same as finding a basis in which the adjacency matrix of G becomes
 that of G'.
 Testing all solutions is equivalent to testing all permutations and a naive
 algorithm would take 
\begin_inset Formula $n!$
\end_inset

 operations.
 
\end_layout

\begin_layout Standard
The GI problem lies between the complexity classes P and NP and Schöning
 
\begin_inset CommandInset citation
LatexCommand cite
key "Schoening1988"

\end_inset

 proved that it is not NP-complete unless 
\begin_inset Formula $P=NP$
\end_inset

.
 However, no polynomial solution has been found and the best deterministic
 algorithm so far is due to Eugene Luks and runs in 
\begin_inset Formula $2^{O(\sqrt{n\, logn})}$
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Babai1983"

\end_inset

.
 However some efficient heuristics are available, including 
\emph on
nauty
\emph default
 and 
\emph on
conauto
\emph default
, which runs in 
\begin_inset Formula $O(n^{5})$
\end_inset

 with very high probability for any graph in 
\begin_inset Formula $G(n,p)$
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Lopez-Presa2009"

\end_inset

.
 In our algorithm and test we often consider multi-graphs, as the hard cases
 are much easier to generate for multi-graphs and the difference has no
 impact on our heuristic.
 Finally, we tried to make an heuristic which would behave well when launched
 on p different graphs to check if any two are isomorphic.
\end_layout

\begin_layout Section
The Heuristics
\end_layout

\begin_layout Subsection
The Weisfeiler-Lehman heuristic
\end_layout

\begin_layout Standard
The original Weisfeiler-Lehman (WL) heuristic works by coloring the edges
 of a graph according to the following rules :
\end_layout

\begin_layout Itemize
We begin with a coloring that assigns to every vertex the same color (this
 is the 1-dimensional version).
\end_layout

\begin_layout Itemize
At each pass, the color of each vertex is determined by the number of neighbours
 of color c for each c.
\end_layout

\begin_layout Itemize
After at most n passes, the colors don't change anymore.
 We then make one random choice before coloring again, using backtracking.
 
\end_layout

\begin_layout Standard
These rules actually only produce a certificate of non-isomorphism.
 To construct an isomorphism using WL one uses backtracking coupled with
 the fact that the image of a vertex has to be of the same color.
 It is easy to see that two isomorphic graphs behave in the same way when
 subject to WL coloring, but the converse does not generally hold.
 Notably, some special classes of graphs make backtracking omnipresent,
 e.g.
 in k-regular graphs, thus leading to time complexity up to 
\begin_inset Formula $O(n^{n})$
\end_inset

.
 The heuristic can be improved by changing the initial coloring of the vertices,
 but we shall only study this case.
\end_layout

\begin_layout Subsection
The PN heuristic
\end_layout

\begin_layout Subsubsection
The idea
\end_layout

\begin_layout Standard
PN is based on the following property : 
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $N_{k}(x)$
\end_inset

 be the number of neighbours at distance exactly k from x, and 
\begin_inset Formula $P_{k}(x)$
\end_inset

 the number of paths of length k starting from x, then if 
\begin_inset Formula $f$
\end_inset

 is an isomorphism between 
\begin_inset Formula $G$
\end_inset

 and 
\begin_inset Formula $G'$
\end_inset

, 
\begin_inset Formula $N_{k}(x)=N_{k}(f(x))$
\end_inset

 and 
\begin_inset Formula $P_{k}(x)=P_{k}(f(x))$
\end_inset

.
 Thus, by computing the different 
\begin_inset Formula $N_{x}$
\end_inset

 and 
\begin_inset Formula $P_{x}$
\end_inset

 we can prune the search tree and limit the possibilities.
 We name 
\begin_inset Formula $PN(x)$
\end_inset

 the array of couples 
\begin_inset Formula $P_{k}(x),N_{k}(x)$
\end_inset

 for k between 1 and n, and compute an array containing 
\begin_inset Formula $PN(x)$
\end_inset

 for each x, obtaining the PN arrays.
 
\end_layout

\begin_layout Subsubsection
Structure of the algorithm
\end_layout

\begin_layout Standard
The algorithm we use actually incorporates multiple testing phases to quickly
 eliminate easy cases.
 It can be decomposed in the following steps : 
\end_layout

\begin_layout Enumerate
Input parsing and choice of data structure
\end_layout

\begin_layout Enumerate
Primary test phase
\end_layout

\begin_layout Enumerate
Construction of each PN-array 
\end_layout

\begin_layout Enumerate
Sorting and comparison of the PN-arrays 
\end_layout

\begin_layout Enumerate
Comparison of the neighbourhoods of compatible vertices
\end_layout

\begin_layout Enumerate
If possible construction of an isomorphism by refined bruteforce
\end_layout

\begin_layout Subsubsection
Details 
\end_layout

\begin_layout Standard
We keep a list of equivalence classes for the vertices of both graphs.
 Each information we gather with the different tests allows us to refine
 the separation into classes, and when they are not compatible to produce
 a certificate of non-isomorphism.
 Every class of cardinal 
\begin_inset Formula $c$
\end_inset

 has at most 
\begin_inset Formula $c!$
\end_inset

 possibilities of isomorphism.
 When the product of the 
\begin_inset Formula $c!$
\end_inset

 becomes small, bruteforce becomes possible.
 The goal of the PN matrix is to separate the vertices in as many classes
 as possible, but bruteforce can sometimes be used earlier, as is the case
 in the primary test phase, or during the generation of the PN matrices
 sometimes.
 However, when one computes the PN arrays, it is not always enough, and
 so we use a technique from WL and compare the neighbourhoods of k-order
 of each vertex to see if it is compatible with all of its images, to prune
 some more.
 
\end_layout

\begin_layout Subsubsection
Primary test phase 
\end_layout

\begin_layout Standard
The problem with the naive algorithm is that the number of possibilities
 grows exponentially in n, however, when one considers permutations which
 are composed of one transposition, there are at most 
\begin_inset Formula $n^{2}$
\end_inset

 possibilities and each take at most 
\begin_inset Formula $m$
\end_inset

 operations.
 The first test phase uses different simple techniques to quickly find a
 certificate of non-isomorphism or an easy isomorphism when doing so is
 possible.
 The tests are run in this order : 
\end_layout

\begin_layout Enumerate
Check for equality between the matrices
\end_layout

\begin_layout Enumerate
Check size and number of connected components
\end_layout

\begin_layout Enumerate
Compare the list of degrees and record the number of possibilities
\end_layout

\begin_layout Enumerate
When the number of possibilities is small (
\begin_inset Formula $O(n^{2})$
\end_inset

) use bruteforce
\end_layout

\begin_layout Section
Tests and performance
\end_layout

\begin_layout Subsection
Random generation
\end_layout

\begin_layout Standard
We have included different basic test generation programs, depending on
 the model : 
\end_layout

\begin_layout Itemize
The Erdös-Rényi 
\begin_inset Formula $G(n,p)$
\end_inset

 model with probability p for each edge works in general quite fast because
 the probability that two graphs are not isomorphic (and trigger a certificate)
 is very high.
 
\end_layout

\begin_layout Itemize
The similar model with 
\begin_inset Formula $G(n,M)$
\end_inset

 behaves the same way.
 There is a deterministic multigraph version and a probabilistic version
 in the other case.
 
\end_layout

\begin_layout Itemize
A model to generate random k-regular multigraphs that generates k random
 permutations of n vertices and links each vertice of the initial array
 to each of its images in the resulting permutations.
 
\end_layout

\begin_layout Standard
All other methods so far for generating k-regular graphs (and not multigraphs)
 are probabilistic except for very small k, and when 
\begin_inset Formula $k\ge log(n)$
\end_inset

 have exponential expected time 
\begin_inset CommandInset citation
LatexCommand cite
key "Wormwald:UniformGeneration"

\end_inset

, so we mostly restricted ourselves to those three models, as our algorithm
 should work as well on multigraphs as on normal graphs.
 
\end_layout

\begin_layout Subsection
Isomorphic graph generation
\end_layout

\begin_layout Standard
To generate two isomorphic graphs is actually really easy : as two graphs
 are isomorphic if and only if their adjacency matrices are similar, one
 has to compute a random permutation (which corresponds to a change of basis),
 and to apply it to any graph to obtain an isomorphic copy.
 We generate those from all three different models of random graphs already
 implemented.
 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
Performance
\end_layout

\begin_layout Standard
\paragraph_spacing single
We checked the performance of PN on the three types of non-isomorphic graphs
 and here are the results (time in seconds), including parsing time (On
 an intel core i7 2.3Ghz with ubuntu 12.10)
\end_layout

\begin_layout Standard
\begin_inset Phantom HPhantom
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing double
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n in G(n,p)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
p
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
time
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.05
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.002
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.05
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.039
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.05
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13.9
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.008
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.5
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n in G(n,M)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
M
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
time
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.007
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.087
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
200000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.22
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
500000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.84
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2000000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9.1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2000000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k-regular
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
time
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.016
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
200
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.48
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
500
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8.2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.012
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
200
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.49
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
500
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8.2
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Phantom HPhantom
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing single
We saw that in the G(n,p) and G(n,m) the work is most often done by the
 primary test phase, and in k-regular by the first two multiplications of
 the matrix.
 The same tests run on multigraphs show very similar results:
\end_layout

\begin_layout Standard
\begin_inset Phantom HPhantom
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing double
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n in G(n,M)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
M
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
time
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.006
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.090
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
200000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.24
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
500000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.85
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2000000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9.3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2000000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.4
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k-regular
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
time
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.018
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
200
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.48
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
500
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8.0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.016
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
200
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.48
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
500
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8.0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Phantom HPhantom
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing double
Finally, run on isomorphic graphs : 
\end_layout

\begin_layout Standard
\begin_inset Phantom HPhantom
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing double
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n in G(n,p)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
p
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
time
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.05
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.092
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
300
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.05
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
500
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.05
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8.5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.065
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
300
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
500
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8.5
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k-regular
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
time
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.029
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.026*
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
500
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
43
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.39
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.9
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
500
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3930
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Phantom HPhantom
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing single
The running time in the k-regular case varies a lot (the * case once took
 about 6s).
 PN proved indeed useful as it reduces drastically the number of possibilities
 around the fifth multiplication.
 The use of neighbourhood simplification at the end also reduces the number
 of possibilities quite fast.
 However, when launched on bigger graphs, it is still slow.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Comparison with Weisfeiler-Lehman
\end_layout

\begin_layout Subsection
Proof
\end_layout

\begin_layout Standard
Our current algorithm incorporates elements from WL at the end, to facilitate
 this proof.
 We had an initial proof that did not rely on that part but we realized
 it was flawed one day before the deadline for this report, so even though
 that bit of code might never be used in practice it allows us to show that
 the subset of problems solved polynomially is strictly greater than the
 subset solved by WL.
 It might be possible to show that with minimal modifications our algorithm
 doesn't need that part, but we had no time to try to do so.
 
\end_layout

\begin_layout Standard
We shall consider an extended version of WL (EWL) to facilitate the proof,
 where colors aren't redistributed among 
\begin_inset Formula $[1;n]$
\end_inset

 but are instead an injective function of the vertex's previous color and
 the multiset of its neighbours' colors into the set of colors (which is
 not anymore included in 
\begin_inset Formula $[1;n]$
\end_inset

).
 Two cases allow WL to reduce the number of possibilities and hence have
 a polynomial runtime : the first is when the colorings of G and G' are
 incompatible, and the second when there is a color shared by an unique
 vertex in each graph.
 
\end_layout

\begin_layout Standard
We must show three properties : 
\end_layout

\begin_layout Itemize
When the graphs are isomorphic, WL, EWL and PN compute the isomorphism,
 and produce a negative certificate in the other case (correctness)
\end_layout

\begin_layout Itemize
When WL finds two incompatible coloring, then so does EWL, and PN also gives
 a negative certificate (polynomial negative certificate)
\end_layout

\begin_layout Itemize
When WL colors a vertex in an unique color in both graphs, then EWL does
 the same, and our algorithm also recognizes that those two vertices must
 be linked if the graphs are isomorphic (polynomial isomorphism)
\end_layout

\begin_layout Standard
The first is immediate, because the operations we use are invariant through
 permutations of the vertices, hence if the two graphs are isomorphic it
 might take exponential time but will surely end.
 The two other properties trivially hold for extended WL, and we must show
 that it implies that they hold for PN.
 However, there is an advantage of EWL over WL, because the coloring is
 unique for the two graphs (it being injective), so if there is exactly
 one vertex in each graph colored by C, then the isomorphism must assign
 one to the other (problems may arise in WL because the coloring is not
 necessarily injective).
 This gives an easy proof of the third depending on the second, because
 the fact that a vertex is colored uniquely in G and G' is implied by the
 fact that it is colored differently from every single other vertex.
 Hence we must only prove the second property.
\end_layout

\begin_layout Standard
We shall proceed by induction to prove that if EWL colors a vertice in G
 and another in G' in different colors at run k, then PN also allows us
 to differentiate those two vertices before examining neighbourhoods for
 the k-th time.
 
\end_layout

\begin_layout Standard
At the first run of the coloring, every vertex is colored by its degree
 so it is trivially true.
 
\end_layout

\begin_layout Standard
Now let us suppose that the property holds at run k, and show that it holds
 at run k+1 : 
\end_layout

\begin_layout Standard
Consider two vertices V and W (one per graph) that had the same color for
 all previous runs, but which are colored differently at run k+1.
 Then their neighbourhoods are incompatible, which means that the multiset
 of colors is not the same, so there is a color c such that there is one
 more vertex of color c in N(V) than in N(W).
 However, those colors were attributed at run k, so it means that when comparing
 the lists of neighbours of V and W in PN at run k, those lists will be
 incompatible by hypothesis.
 Hence V and W can't be linked in PN, which ends the induction.
 
\end_layout

\begin_layout Subsection
Complexity analysis
\end_layout

\begin_layout Standard
As the GI problem isn't known to be in P, it is not absurd to have a worst
 running time of 
\begin_inset Formula $O(n!)$
\end_inset

.
 However, we can go into details and see that in most cases the real running
 time is generally much lower.
 
\end_layout

\begin_layout Standard
The reading phase takes at least 
\begin_inset Formula $O(m)$
\end_inset

, but is implemented in 
\begin_inset Formula $O(n^{2})$
\end_inset

 as we use matrices.
 
\end_layout

\begin_layout Standard
The first test phase consists of a list of at most five tests of increasing
 time complexity, to quickly solve cases of increasing difficulty.
 
\end_layout

\begin_layout Standard
The first three tests run in 
\begin_inset Formula $O(n^{2})$
\end_inset

 although they could be implemented in 
\begin_inset Formula $O(m+n*log(n))$
\end_inset

.
 
\end_layout

\begin_layout Standard
The last takes at most 
\begin_inset Formula $O(n^{4})$
\end_inset

 but only 
\begin_inset Formula $O(n^{2}m)$
\end_inset

 when run on lists.
 However, even though this polynomial is of high degree, it does not effectively
 take as much time because most of the tests fail immediately, hence its
 presence before PN has an utility.
 
\end_layout

\begin_layout Standard
The most time-consuming phase is the array generation.
 It does n multiplications of 
\begin_inset Formula $n*n$
\end_inset

 matrices for each graph, which takes 
\begin_inset Formula $O(n^{4})$
\end_inset

 and a sort after that (which takes at most 
\begin_inset Formula $O(n^{2}log(n))$
\end_inset

).
 We could have used Strassen to decrease that cost but the overhead on small
 matrices reduces its interest.
 
\end_layout

\begin_layout Standard
The next phase is the comparison of the arrays.
 It takes at most 
\begin_inset Formula $O(n^{2})$
\end_inset

, and when we also check compatibility with the neighbours we obtain 
\begin_inset Formula $O(n^{3}log(n))$
\end_inset

.
\end_layout

\begin_layout Standard
If we haven't found an isomorphism or a negative certificate by then we
 launch a bruteforce on the remaining possibilities, which at worst runs
 in 
\begin_inset Formula $O(n!)$
\end_inset

.
 
\end_layout

\begin_layout Standard
A quick analysis of WL gives a higher bound (in polynomial cases) of 
\begin_inset Formula $O(mn^{2})$
\end_inset

 when implemented with adjacency lists although the expected running time
 is lower.
 We can then separate the problems in four categories: 
\end_layout

\begin_layout Enumerate
The very simple ones that are solved much faster by PN thanks to the primary
 test phase
\end_layout

\begin_layout Enumerate
The medium-easy cases that are solved by PN but not the primary test phase,
 and where WL is asymptotically better
\end_layout

\begin_layout Enumerate
The medium-hard cases that are solved polynomially by PN but exponentially
 by WL
\end_layout

\begin_layout Enumerate
The hard cases where both algorithms behave exponentially.
 
\end_layout

\begin_layout Standard
Also, every information we gather doing initial tests can be used by the
 following ones, which wouldn't be the case with WL (it would use the previous
 ones but would have no impact on the following ones).
 
\end_layout

\begin_layout Subsection
Differences when run on k graphs
\end_layout

\begin_layout Standard
One advantage of PN is when it is run on k different graphs, as the PN matrices
 can then be sorted in 
\begin_inset Formula $O(k*log(k))$
\end_inset

 time, instead of launching a comparison algorithm 
\begin_inset Formula $k^{2}$
\end_inset

 times.
 Also the generation of PN matrice can easily be parallelized.
 It is an advantage over WL as the latter is very hard to parallelize in
 such fashion.
 When run on only two graphs however, we can interlace the sorting-and-comparing
 phase with the generation of the PN matrix, thus greatly reducing the running
 time (as most cases can be solved by only computing the first few multiplicatio
ns of PN).
\end_layout

\begin_layout Section
Implementation and Optimization
\end_layout

\begin_layout Subsection
Implementation problems
\end_layout

\begin_layout Standard
The biggest problem was that the numbers in the PN matrix quickly grow out
 of proportions (one can bound them by 
\begin_inset Formula $n^{n}$
\end_inset

 but this bound might be reached), so one has to use multiplication modulo
 p, and we chose a prime number p close to 
\begin_inset Formula $2^{61}$
\end_inset

 to be able to do bit-shift easily while having low probability of collisions.
 We also added another version where the modulo is done with 
\begin_inset Formula $p<2^{32}$
\end_inset

, that is much faster although the probability of collision is also higher.
 This means that our implementation is only probabilistic, and there is
 a small chance that it behaves exponentially where another implementation
 would not.
 Then again, it might never happen, depending on how collisions happen,
 but we have not looked into this possibility.
\end_layout

\begin_layout Standard
The sorting was also source of problems because manual implementations behave
 quite slower than the ones included in the libraries so we used qsort_r
 to increase performance, which is not a standard function.
 
\end_layout

\begin_layout Standard
Finally, we had to use some goto in the code, to be sure to free the memory.
 One could implement PN without them, but it would necessitate changing
 the whole control flow.
 
\end_layout

\begin_layout Subsection
Function Optimization
\end_layout

\begin_layout Standard
As with many graph algorithms, PN can be improved by using adjacency lists
 in the case of sparse graphs.
 However, that seldom changes the asymptotic complexity, as the PN-array
 generation can only benefit from it in case of graphs with very poor expansion
 properties.
 The list representation is mostly used in the primary test phase, where
 it allows us to have tests in 
\begin_inset Formula $O(m)$
\end_inset

 instead of 
\begin_inset Formula $O(n^{2})$
\end_inset

.
 Optimization on the matrix operations cannot really be done in practice
 as Strassen's algorithm has no interest on the matrix size we generally
 consider.
 However we took care of memory locality in their representation, which
 might improve the performance in practice.
 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
Parallelism
\end_layout

\begin_layout Standard
The advantage of the PN-arrays is that they can be generated in a completely
 independent fashion, and so are easy to parallelize.
 This is an advantage of PN over WL as the threads do not have to communicate,
 while the latter has to do some comparisons between each coloring at each
 run, requiring constant interaction between threads.
 In practice the version that runs on two graphs is monothread and interlaces
 the equivalence class creation with PN to run faster, but this improvement
 couldn't be used in a parallelized version.
 
\end_layout

\begin_layout Subsection
Potential improvements
\end_layout

\begin_layout Standard
Due to time constraints we couldn't implement as many functions as we hoped
 to, but here's a list of potential improvements : 
\end_layout

\begin_layout Itemize
Optimize the mulp function, which is the bottleneck of the algorithm.
 This has been done partially with mulp_small at the price of a small probabilit
y of going exponential.
 A detailed analysis of the cases when this could arise might even allow
 us to use naive multiplication modulo 
\begin_inset Formula $2^{64}$
\end_inset

 but it isn't sure.
 
\end_layout

\begin_layout Itemize
Parallelization inside the matrix multiplication could yield good results.
 We ran some tests on how well parallelization works on our machine (with
 the sorting algorithms for PN), with and without multithreading, and we
 obtain increase in speed up to a factor 4 plus a 30% increase when using
 multithreading.
\end_layout

\begin_layout Itemize
Interlacing the neighbourhood function with the PN generation would greatly
 improve the speed, but would complexify the proof.
\end_layout

\begin_layout Itemize
We hesitated whether to add a fifth primary test that would try for all
 simple transpositions, which runs quite fast.
 That kind of method might come in handy when the two graphs are very 
\begin_inset Quotes eld
\end_inset

close
\begin_inset Quotes erd
\end_inset

 (i.e.
 we could imagine that there is a perturbation on the order the vertices
 are received).
\end_layout

\begin_layout Itemize
A very efficient Strassen multiplication might also be useful, mostly if
 we want to run PN on bigger graphs.
 
\end_layout

\begin_layout Subsection
Files and usage
\end_layout

\begin_layout Standard
All the files can be found at
\begin_inset CommandInset href
LatexCommand href
target " http://github.com/koliaza/Heuristitique"

\end_inset

.
 The files can be separated into three categories (plus the pdf and tex
 files) : 
\end_layout

\begin_layout Itemize
Basic functions : io.c, util.c, matrix_mod.c, partitions.c
\end_layout

\begin_layout Itemize
Graph functions : graph.c, random_graph.c, pn_heuristic.c
\end_layout

\begin_layout Itemize
Global functions : main.c, test_gen.c
\end_layout

\begin_layout Standard
Commands : one uses main, with the option --verbose, on either two filenames
 or a directory (for k graphs).
 test_gen can be called with no arguments to see the exact syntax.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "bibliography algorithms"
options "plain"

\end_inset


\end_layout

\end_body
\end_document

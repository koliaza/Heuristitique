#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman palatino
\font_sans default
\font_typewriter default
\font_default_family rmdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref section
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
An heuristic for graph isomorphisms
\end_layout

\begin_layout Author
\begin_inset ERT
status open

\begin_layout Plain Layout

Nguy
\backslash
~{
\backslash
^e}n Lê Thành D
\backslash
~ung 
\backslash
and  Blanchard Nicolas Koliaza
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Foreword 
\end_layout

\begin_layout Standard
The problem considered is the graph isomorphism (GI) problem : given two
 graphs 
\begin_inset Formula $G$
\end_inset

 and 
\begin_inset Formula $G'$
\end_inset

, can one compute an isomorphism between them.
 The original goal was to implement the Weisfeiler-Lehman heuristic in the
 C programming language, but we chose to implement our own heuristic (named
 PN for path-neighbour) to test its performance.
 The main goal was to find an heuristic which would behave polynomially
 on the a bigger subset of problems, even if the polynomial degree increases.
 
\end_layout

\begin_layout Section
Algorithmical Considerations
\end_layout

\begin_layout Standard
We adopt the notations of graphs with n vertices and m edges.
 
\begin_inset Formula $G(n,p)$
\end_inset

 denotes the graph generated through the Erdös-Rényi model with n vertices
 and probability p for each edge.
 
\end_layout

\begin_layout Standard
There is a strong link between GI and algebra : finding an isomorphism is
 the same as finding a basis in which the adjacency matrix of G becomes
 that of G'.
 Testing all solutions is equivalent to testing all permutations and a naïve
 algorithm would take 
\begin_inset Formula $n!$
\end_inset

 operations.
 The GI problem lies between the complexity classes P and NP and Schöning
 
\begin_inset CommandInset citation
LatexCommand cite
key "Schoening1988"

\end_inset

 proved that it is not NP-complete unless 
\begin_inset Formula $P=NP$
\end_inset

.
 However, no polynomial solution has been found and the best deterministic
 algorithm so far is due to Eugene Luks and runs in 
\begin_inset Formula $2^{O(\sqrt{n\, logn})}$
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Babai1983"

\end_inset

.
 However some efficient heuristics are available, including 
\emph on
nauty
\emph default
 and 
\emph on
conauto
\emph default
, which runs in 
\begin_inset Formula $O(n^{5})$
\end_inset

 with very high probability for any graph in 
\begin_inset Formula $G(n,p)$
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Lopez-Presa2009"

\end_inset

.
 In our algorithm and test we often consider multi-graphs, as the hard cases
 are much easier to generate for multi-graphs and the difference has no
 impact on our heuristic.
 Finally, we tried to make an heuristic which would behave well when launched
 on p different graphs to check if any two are isomorphic.
\end_layout

\begin_layout Section
The Heuristics
\end_layout

\begin_layout Subsection
The Weisfeiler-Lehman heuristic
\end_layout

\begin_layout Standard
The original Weisfeiler-Lehman (WL) heuristic works by coloring the edges
 of a graph according to the following rules :
\end_layout

\begin_layout Itemize
We begin with a coloring that assigns to every vertex the same color (this
 is the 1-dimensional version).
\end_layout

\begin_layout Itemize
At each pass, the color of each vertex is determined by the number of neighbours
 of color c for each c.
\end_layout

\begin_layout Itemize
After at most n passes, the colors don't change anymore.
\end_layout

\begin_layout Standard
These rules actually only produce a certificate of non-isomorphism.
 To construct an isomorphism using WL one uses backtracking coupled with
 the fact that the image of a vertex has to be of the same color.
 It is easy to see that two isomorphic graphs behave in the same way when
 subject to WL coloring, but the converse does not generally hold.
 Notably, some special classes of graphs make backtracking omnipresent,
 e.g.
 in k-regular graphs, thus leading to time complexity up to 
\begin_inset Formula $O(n^{n})$
\end_inset

.
 The heuristic can be improved by changing the initial coloring of the vertices,
 but we shall only study this case.
\end_layout

\begin_layout Subsection
Another heuristic
\end_layout

\begin_layout Subsubsection
The idea
\end_layout

\begin_layout Standard
PN is based on the following property : 
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $N_{k}(x)$
\end_inset

 be the number of neighbours at distance exactly k from x, and 
\begin_inset Formula $P_{k}(x)$
\end_inset

 the number of paths of length k starting from x, then if 
\begin_inset Formula $f$
\end_inset

 is an isomorphism between 
\begin_inset Formula $G$
\end_inset

 and 
\begin_inset Formula $G'$
\end_inset

 , 
\begin_inset Formula $N_{k}(x)=N_{k}(f(x))$
\end_inset

 and 
\begin_inset Formula $P_{k}(x)=P_{k}(f(x))$
\end_inset

.
 Thus, by computing the different 
\begin_inset Formula $N_{x}$
\end_inset

 and 
\begin_inset Formula $P_{x}$
\end_inset

 we can prune the search tree and limit the possibilities.
 We name the array of couples 
\begin_inset Formula $P_{k}(x),N_{k}(x)$
\end_inset

 for k between 1 and n PN(x), and compute an array containing PN(x) for
 each x, obtaining the 
\begin_inset Formula $n\times n$
\end_inset

 matrix PN.
 
\end_layout

\begin_layout Subsubsection
Structure of the algorithm
\end_layout

\begin_layout Standard
The algorithm we use actually incorporates multiple testing phases to quickly
 eliminate easy cases.
 It can be decomposed in the following steps : 
\end_layout

\begin_layout Enumerate
Lecture and choice of data structure
\end_layout

\begin_layout Enumerate
Primary test phase
\end_layout

\begin_layout Enumerate
Construction of each PN-array 
\end_layout

\begin_layout Enumerate
Sorting of each PN-array
\end_layout

\begin_layout Enumerate
Comparison of the PN-arrays 
\end_layout

\begin_layout Enumerate
Comparison of the neighbours of compatible vertices.
\end_layout

\begin_layout Enumerate
If possible construction of an isomorphism by refined bruteforce
\end_layout

\begin_layout Subsubsection
Details 
\end_layout

\begin_layout Standard
We keep the list of image-possibilities for all vertices in a matrix form.
 When one line or column becomes full of zeroes, we have a negative certificate.
 The matrix actually corresponds to classes of an equivalence relation,
 and every class of cardinal c has at most 
\begin_inset Formula $c!$
\end_inset

 possibilities of isomorphism.
 When the product of the 
\begin_inset Formula $c!$
\end_inset

 becomes small, bruteforce becomes possible.
 The goal of the PN matrix is to separate the vertices in as many classes
 as possible, but bruteforce can sometimes be used earlier, as is the case
 in the primary test phase.
 However, when one computes the PN matrix, it is not always enough, and
 so we use a technique from WL and compare the immediate neighbourhood of
 each vertex to see if it is compatible with all of its images, to prune
 some more.
 
\end_layout

\begin_layout Subsubsection
Primary test phase 
\end_layout

\begin_layout Standard
The problem with the naïve algorithm is that the number of possibilities
 groes exponentially in n, however, when one considerons permutations which
 are composed of one transposition, there are at most 
\begin_inset Formula $n^{2}$
\end_inset

possibilities and each take at most 
\begin_inset Formula $m$
\end_inset

 operations.
 The first test phase uses different simple techniques to quickly find a
 certificate of non-isomorphism or an easy isomorphism when doing so is
 possible.
 The tests are run in this order : 
\end_layout

\begin_layout Enumerate
Check for equality between the matrices (runs in 
\begin_inset Formula $O(m)$
\end_inset

)
\end_layout

\begin_layout Enumerate
Check size and number of connected components (in 
\begin_inset Formula $O(m)$
\end_inset

)
\end_layout

\begin_layout Enumerate
Compare the list of degrees (in 
\begin_inset Formula $O(m+n*log(n))$
\end_inset

 ) and record the number of possibilities.
\end_layout

\begin_layout Enumerate
When the number of possibilities is small (
\begin_inset Formula $O(n^{2})$
\end_inset

) use bruteforce (in 
\begin_inset Formula $O(n^{2}*m)$
\end_inset

 ).
\end_layout

\begin_layout Enumerate
Still check for simple transpositions when it is not the case ( also in
 
\begin_inset Formula $O(n^{2}*m)$
\end_inset

 )
\end_layout

\begin_layout Subsubsection
Details and optimization
\end_layout

\begin_layout Standard
The choice of data structures varies between adjacency matrix and list,
 and sometimes both, and allows us to take advantage of faster algorithms
 on sparse graphs using lists, while allowing us to know in O(1) if two
 vertices are linked.
 
\end_layout

\begin_layout Standard
The construction of the N-array is generally the most time-expensive task,
 it is mostly done by multiplication of the adjacency matrix (or by equivalent
 operations on lists).
 Sorting the N-array is easily done with a heapsort.
 The construction of the isomorphism is done by trying to assign to an x
 an y such that
\begin_inset Formula $N(x)=N(y)$
\end_inset

 and backtracking when unsuccessfull.
 
\end_layout

\begin_layout Standard
Some code optimizationsmight be added : the construction of N-arrays by
 matrix multiplication can be parallelized easily, and multi-threading could
 be used to do so.
 It can also be used it for sorting the arrays.
 However we didn't use Strassen's algorithm because for the matrix size
 considered (
\begin_inset Formula $n\le500$
\end_inset

) the gain is very small and mostly compensated by the overhead.
 
\end_layout

\begin_layout Section
Tests and Benchmark
\end_layout

\begin_layout Standard
We have included different basic test generation programs, depending on
 the model : 
\end_layout

\begin_layout Subsection
Random generation
\end_layout

\begin_layout Itemize
The Erdös-Rényi 
\begin_inset Formula $G(n,p)$
\end_inset

 model with probability p for each edge works in general quite fast because
 the probability that two graphs are not isomorphic (and trigger a certificate)
 is very high.
 
\end_layout

\begin_layout Itemize
The similar model with 
\begin_inset Formula $G(n,M)$
\end_inset

 behaves the same way.
\end_layout

\begin_layout Itemize
A model to generate random k-regular multigraphs that generates k random
 permutations of n vertices and links each vertice of the initial array
 to each of its images in the resulting permutations.
 
\end_layout

\begin_layout Standard
All other methods so far for generating k-regular graphs (and not multigraphs)
 are probabilistic except for very small k, and when 
\begin_inset Formula $k\ge log(n)$
\end_inset

 have exponential expected time 
\begin_inset CommandInset citation
LatexCommand cite
key "Wormwald:UniformGeneration"

\end_inset

, so we restricted ourselves to those three models, as our algorithm should
 work as well on multigraphs as on normal graphs.
\end_layout

\begin_layout Subsection
Isomorphic graph generation
\end_layout

\begin_layout Standard
To generate two isomorphic graphs is actually really easy : as two graphs
 are isomorphic if and only if their adjacency matrices are similar, one
 has to compute a random permutation (which corresponds to a change of basis),
 and to apply it to any graph to obtain an isomorphic copy.
 We generate those from all three different models of random graphs already
 implemented.
 
\end_layout

\begin_layout Subsection
Benchmark
\end_layout

\begin_layout Section
Comparison with Weisfeiler-Lehman
\end_layout

\begin_layout Standard
Our goal here is to show that the subset of problems solved in polynomial
 time by WL is strictly included in the subset solved by our heuristic.
 We shall consider an extended version of WL (EWL) to facilitate the proof,
 where colors aren't redistributed among 
\begin_inset Formula $[1;n]$
\end_inset

 but are instead an injective function of the vertex's previous color and
 the multiset of its neighbour's colors.
 When WL behaves polynomially, it does so by either finding that two vertices
 must be image of one another by the isomorphism (if it exists) or by finding
 a negative certificate.
 We must show those three properties : 
\end_layout

\begin_layout Itemize
When WL colors a vertex in an unique color in both graphs, then EWL does
 the same, and our algorithm also recognizes that those two vertices must
 be linked if the graphs are isomorphic (polynomial search of isomorphism)
\end_layout

\begin_layout Itemize
When WL finds two incompatible coloring, then so does EWL, and our algorithm
 also gives a negative certificate (polynomial negative certificate)
\end_layout

\begin_layout Itemize
When the graphs are isomorphic, WL, EWL and our heuristic compute the isomorphis
m (correctness)
\end_layout

\begin_layout Standard
The third is immediate, because the operations we use are invariant through
 permutations of the vertices, hence if the two graphs are isomorphic it
 might take exponential time but will surely end.
 The two other properties trivially hold for extended WL, and we must show
 that it implies that they hold for our algorithm.
 
\end_layout

\begin_layout Standard
We shall proceed by induction to prove that if EWL colors a vertice in G
 and another in G' in different colors, then our PY algorithm also allows
 us to differentiate those two vertices.
 At the first run of the coloring, every vertex is colored by its degree
 so it is trivially true.
 
\end_layout

\begin_layout Standard
Now let us suppose that the property holds at run n, and show that it holds
 at run n+1 : 
\end_layout

\begin_layout Standard
Consider two vertices V and W (one per graph) that had the same color for
 all previous runs, but which are colored differently at run n+1.
 Then their neighbourhoods are incompatible, which means that the multiset
 of colors is not the same, so there is a color c such that there is one
 more vertex of color c in N(V) than in N(W).
 However, those colors were attributed at run n, so it means that when comparing
 the PN lists of neighbours of V and W, those lists will be incompatible.
 Hence V and W can't be linked in PN, which ends the induction.
 
\end_layout

\begin_layout Standard
This also means that if V and W are colored in the same unique color, then
 they are linked if possible ( because they can't be linked to any other
 vertices) so the second property also holds.
 
\end_layout

\begin_layout Standard
Consider that EWL computes the colors of V and W and that they are not compatibl
e.
 We must show that they can't be compatible in PN.
 
\end_layout

\begin_layout Standard
We proceed by induction.
 The initialisation is easy : apart from the case where everyone is colored
 in the same way, the first run which computes the degrees of all vertices
 is trivially handled as well by PN.
 
\end_layout

\begin_layout Standard
Let us suppose that 
\begin_inset Formula $\forall V\in G,\forall W\in G'$
\end_inset

, if the color of V and W
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "bibliography algorithms"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
